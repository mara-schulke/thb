\documentclass[journal]{IEEEtran}

\usepackage[a4paper, left=2cm, right=2cm, top=2cm, bottom=3cm]{geometry}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{lipsum}
\usepackage{xcolor}

\hypersetup{colorlinks=true, allcolors=black}

\title{Ansätze zum Echtzeit-Video-Streaming im Web}
\author{
	\IEEEauthorblockN{Maximilian Schulke \textit{(Matrikel-Nr. 20215853)}}\\
	\IEEEauthorblockA{
		Technische Hochschule Brandenburg \\
		B.Sc. Medieninformatik \\
		Computergrafik
	}
}


\begin{document}

\markboth{Hausarbeit Computergrafik – Maximilian Schulke}{}
\IEEEspecialpapernotice{
	betreut durch Prof.\ Dr.\ rer.\ nat.\ Reiner Creutzburg\\
	Wintersemester 2021\\
	Abgabetermin \today
}

\maketitle

\begin{abstract}
	\lipsum[1-2][2-3]
	\lipsum[1-2][2-3]
	Das abstract schreibe ich zu letzt!
\end{abstract}

\tableofcontents

\newpage

\section{Einleitung / Motivation}
\IEEEPARstart{M}{\MakeLowercase{it}} der zunehmenden Vernetzung der Arbeitswelt
in den letzten Jahren \textcolor{red}{quelle suchen corona zoom} werden auch
digitale Meeting-Systeme immer relevanter und müssen immer mehr Nutzer in
Echtzeit mit einander verbinden um einen reibungslosen Arbeitsalltag zu
gewährleisten. Dies impliziert natürlich auch dass eine \textcolor{red}{quelle
suchen ab wann gute Qualität} Verbindungsqualität gegeben sein muss, damit die
Systeme nutzbar bleiben.

\textcolor{red}{\& sicherheitsaspekt}
Aber wie können wir skalierbare Meeting-Systeme realisieren ohne große
Datenmengen über einen Streaming-Server zu schicken der diese an alle anderen
broadcasted? Die Entwicklung der letzten Jahre deuten immer mehr darauf hin,
dass \textit{Peer-To-Peer} basierte Lösungensansätze aufgrund der besseren
Performance und Skalierbarkeit, in der Regel die bessere Wahl darstellen
\textcolor{red}{quelle suchen}. Natürlich spielen zur Auswahl der Architektur
noch weitere Parameter eine wichtige Rolle (z. B. die maximale Bandbreite und
Rechenleistung der Endgeräte), aber mit immer großer werdenden
Heimnetz-Leitungen und zunehmender Rechenleistung der Endgeräte stellt dies
meistens kein Problem mehr da. \textcolor{red}{quelle suchen}.

Die Problematik der Echtzeit-Kommunikation im Web beschäftigt auch
das \textit{W3C} seit 2011 im Zuge der Standardisierung des seit diesem Jahr
zum Web-Standard erklärten Protokoll \textit{WebRTC}. \textcolor{red}{quelle
suchen}.

Es ist also (immer noch) eine sehr aktuelle Thematik in der Informatik
Echtzeit- oder \textcolor{blue}{Nahe-Zu-Echtzeit-Kommunikation} zuverlässig zu
bewältigen. Die Aufgabe dieser Arbeit soll sein, einen Überblick über den
Stand der Architekturmuster, Protokolle und möglicher Problematiken bei der
Implementierung von eigenen Echtzeit-Video-Streaming-Diensten geben,
\textcolor{orange}{diese anhand eines Experiments durchsprechen und auswerten
usw.}

\section{Historie der Echzeit-Übertragung}

Um zu verstehen wie sich die Protokolle hin zum heutigen Stand entwickelt
haben, ist es besonders interessant nachzuvollziehen wie die ersten Schritte
der IEFT oder auch \textit{Internet Engineering Task Force} bezüglich der
Echtzeit-Kommunikation aussahen, welche Probleme erkannt und behoben wurden und
welche Protokolle heute der Standard sind.

\subsection{1996: RTP \& RTCP – RFC 1889}

Am weitesten reicht das \textit{Real-Time Transport Protocol} oder auch
\textit{RTP} zurück. Es wurde erstmals 1996 von der IEFT standardisiert und
stellt seit dem einen Grundbaustein der datenformatsaganostischen
Echtzeit-Übertragung da. Es kann für diverse
Echtzeit-Übertragungs-Problematiken dienlich sein, da jegliche Binärdaten
verschickt werden können; Somit gibt es keinen ``Lock-In'' auf bestimmte Audio-
oder Video-Codecs. \textcolor{orange}{aussage prüfen und quelle}.

\textit{RTCP} ist das mit \textit{RTP} einhergehende Kontrollprotokoll. Es
wird primär dazu verwendet, die Übertragungsparameter der Sender zu
beeinflussen – z. B. durch ein Feedback zur Übertragungsqualität oder ein
Abmelden der Session. Desweiteren bietet es eine persistente ID für die
\textit{RTP}-Mitglieder, die über Programm-Neustarts hinweg zur Identifikation
von Mitgliedern und der zuordnung von Datenströmen verwendet werden können.
\textcolor{red}{cite rfc1889 kapitel 6 / 6.1 bzw. S. 15-17}

Das Protokoll siedelt sich im TCP/IP-Stack über \textit{UDP} an
\textcolor{red}{cite rfc1889 introduction}. Es fügt wichtige Informationen zu
UDP-Datagrammen hinzu: Im wesentlichen eine Sequenznummer um die
Sende-Reihenfolge zu codieren und einen Payload-Type, der den Codec des
Segments angibt. Somit kann auch bei nicht sequenziell übertragenden
Datagrammen die Ursprüngliche Reihenfolge rekonstruiert werden und es können
bei verlorenen Segmenten Interpolationsalgorithmen verwendet werden.
\textcolor{red}{quelle / beispiele suchen}. Der Payload-Type ist essenziell um
ohne Session-Aushandlung zu kommunizieren wie der Empfänger die Daten zu
decodieren hat, um eine Sinnvolle nachricht zu erhalten.

In der ersten Version aus 1996 gab es einige Probleme bezüglich
\textcolor{red}{Probleme suchen}. Diese wurden 2003 in dem RFC3550
überarbeitet - somit wurde das RFC1889 durch die neuere Version 3550 obsolet.
In der aktuelleren Version wurden einige Änderungen eingearbeit: Im
wesentlichen ``RTCP Packet Send and Receive Rules'' ``Layered Encodings''
``Congestion Control'' ``Security Considerations'' ``IANA Considerations''
\textcolor{orange}{Dummer text}.

Eine wichtige Voraussetzung zur Verwendung von \textit{RTP} ist ein externer
\textit{Signaling-Server}, den alle Beteiligten zur Session-Aushandlung
verwenden. Ein Standard hierfür ist im \textit{RTP-Framework} selbst nicht
definiert, eine beliebte Wahl für ein Protokoll zur Session-Aushandlung ist
allerdings das \textit{Session Initiation Protokoll} (oder kurz \textit(SIP)).
% https://datatracker.ietf.org/doc/html/rfc3550#section-3

\subsection{2004:\ SRTP (RFC 3711)}

Im März 2004 wurden \textit{SRTP} und \textit{SRTCP} vorgestellt – die
verschlüsselten Version von \textit{RTP} bzw. \textit{RTCP}. Diese bauen
weitestgehend auf dem \textit{Advanced Encryption Standard} (kurz.
\textit{AES}) auf \textcolor{red}{(siehe RFC3711 Seite 19).}. Der RFC
beschäftigt sich weitestgehend mit den kryptografischen Aspekten des
Protokolls.

Eine weitverbreitete und offene Implementierung für \textit{SRTP / SRTCP}
wird von der US-Amerikanischen Telekomunikations-Gesellschaft Cisco
bereitgestellt. Diese hat den Namen \textit{libsrtp} und ist öffentlich auf der
Entwickler-Plattform GitHub einsehbar (siehe
\href{https://github.com/cisco/libsrtp}{github.com/cisco/libsrtp}).

% Anwendung in VoIP\!
% https://de.wikipedia.org/wiki/ZRTP

\subsection{2005: RTMP von Adobe}

% https://www.adobe.com/content/dam/acom/en/devnet/rtmp/pdf/rtmp_specification_1.0.pdf
\textit{RTMP} ist ein von der Firma \textit{Adobe Systems Incorporated}
spezifiziertes Protokoll zur Echtzeit-Übertragung von Multimedia-Streams.
\textit{RTMP} wurde laut Spezifikation\textcolor{red}{siehe RTMP spec 1.0},
entwickelt um über dem Transport-Protokoll \textit{TCP} verwendet zu werden.

Das Protokoll wurde dazu entwickelt um im Kontext eines Flash-Players verwendet
zu werden. Dies führt dazu, dass es heutzutage nurnoch bedingt Anwendung
findet, da mittlerweile viele Browser ihren Flash-Player-Support eingestellt
haben (\textcolor{red}{siehe Chrome und Firefox}) % https://support.mozilla.org/en-US/kb/end-support-adobe-flash

Außerdem spricht die hohe Latenz von bis zu 30 Sekunden, die durch die
Verwendung von \textit{TCP} zustandekommt (\textcolor{red}{siehe
restram.io/streaming-protocls}), gegen den Einsatz von \textit{RTMP} in einem
Echtzeit-Übertragungs-Kontext.

Desweiteren gibt es noch Protokollvarianten die HTTP bzw. HTTPS als zugrundeliegendes
Protokoll verwenden.\textcolor{red}{Siehe XYZ Quelle suchen}

\subsection{2010: WebRTC (RFC 8825)}

\textit{WebRTC} ist eine Peer-To-Peer-Technologie die über mehrere Protokolle
und Audio- und Video-Codecs performante und generische
Echtzeit-Kommunikations-Kanäle zwischen Nutzern (oder auch \textit{Peers})
realisiert. Sie 

WebRTC stellt eine direkte Verbindung zwischen zwei Endgeräten her und
verwendet einen mix aus RTP, RTCP, SDP, (ICE Candidates) und einem signaling
server. Es unterstützt beliebte video codecs wie V8 / V9 und ist in der zukunft 
auf AV1 angelegt. Der standard audio codec ist opus.

Durch die direkte verbindung wird eine sogennante sub second latency erreicht.
Dies beschreibt im grunde \textcolor{red}{XYZ}.

% Hat mit 1996 RTP und dann 2005 mit RTMP angefangen, wann kam SRTP?\ JSEP Global IP Solutions \& Google WebRTC kam 2010, Microsoft wollte CU-RTC

% > Datenströme sind verpflichtend zu verschlüsseln. Dazu werden Verbindungen über DTLS verschlüsselt und Audio- und Videokommunikation zusätzlich durch SRTP geschützt.[16]
% https://datatracker.ietf.org/doc/html/rfc8834#section-4.1

% https://www.w3.org/2021/01/pressrelease-webrtc-rec.html.en


Die ersten \textit{Requests for Comments} oder auch \textit{RFC} zu
den grundlegenden Protokollen \textit{RTP} und
\textit{\textcolor{blue}{Protokoll X}}, auf denen die heutigen Protokolle
weitestgehend aufbauen, wurden bereits in den späten 1990er Jahren
veröffentlicht und seit dem immer weiterentwickelt. \textcolor{red}{quelle
anhängen RFC35XX}.

\section{Architekturmuster}

In diesem Kapitel werden zwei der bekanntesten Architekturmuster in der
Echtzeit-Übertragung vorgestellt und verglichen. Es geht primär um die
verteilte Peer-To-Peer Architektur und die zentralisierte Relay / Broadcast
Architektur.

\subsection{Peer-To-Peer}

Auf Grund der hohen Anforderungen an möglichst niedrige Übertragungslatenzen
bietet eine Peer-To-Peer-Architektur klare Vorteile durch den stark verkürzten
Weg, den die Pakete zurücklegen müssen bis sie bei dem Empfänger ankommen.

Deutlich komplizierter wird allerdings die aushandlung bzw.\ initialisierung
einer Verbindung zwischen zwei peers, da diese sich nicht wie bei der typischen
client-server-architektur eine fixe adresse zur verbindung haben. Dieses
problem wird typischerweise über einen signaling server gelöst.

\subsubsection{Signaling Server}
Ein signaling server ist allen peers bekannt und dient als
kommunikationsplattform, damit sich die beiden (sich gegenseitig initial
unbekannten) peers gegenseitig vorstellen können.

Signaling server sind interessanterweise keine feste anforderung für peer to
peer muster. Wenn alle peers immer statische addressen hätten, könnten sie auch
offline ihre ips / ice candidates / sdp offers etc.\ austauschen und so eine
session aufbauen. Wichtig ist leidlgich eine initiale out of band
kommunikation.

Der signaling server kann außerdem noch nach verbindungsaufbau dazu verwendet
werden um die bestehende verbindung zu optimieren. Peers können neue ICE
candidates vorschlagen um die Übertragung an neue gegebenheiten im internet
(z.B. ausfall eines routers) anzupassen. (siehe mdn)

% https://datatracker.ietf.org/wg/wish/about/

\subsubsection{Holepunching}
Holepunching beschreibt den prozess lokale firewalls und nats zu durchbrechen
um eine direkte verbindung zwischen zwei endgeräten herzustellen.

% https://datatracker.ietf.org/doc/html/rfc8834#section-10
% https://de.wikipedia.org/wiki/Multicast
% peer to peer wäre möglich mit ip multicast mit vielen usern ohne pakete zu
% duplizieren

\subsubsection{IP-Multicast}

Je mehr Nutzer / Endgeräte an einer peer-to-peer-übertragung teilnehmen, desto
größer wird die Belastung der Bandbreite bei den einzelnen Teilnehmern. Jedes
Paket muss nicht einmal, sondern n-mal verschickt werden (wobei n die anzahl
der teilnehmer ist). Dies kann bei labilen oder einfach schwachen Netzwerken
entweder zur verminderung der übertragungsqualität führen, oder in besonders
schlimmen fällen sogar das restliche netzwerk eines einzelnen Teilnehmers
negativ beeinflussen, da dieser die meiste Bandbreite für die wiederholte
übertragung gleicher pakete verwendet.

Eine theoretische Lösung für dieses Problem, ist die Verwendung von
IP-Multicast-Adressen. Diese erlauben es einem Gerät ein IP-Paket einmalig zu
übertragen, und dieses von Multicast-Routern im internet multiplizieren zu
lassen. (Siehe grafik)

Vergleichs grafik einfügen..

Dieser ansatz hat klare vorteile: Das gesamte - lokale \& globale – netzwerk
wird geschont. So würde die Anzahl möglicher Teilnehmer deutlich steigen, da
ein Netzwerk-Bottleneck erst bei einem zu großen Download-Volumen des
empfangenen Contents eintreten würde.

\subsection{Relay}
% https://webrtc.org/getting-started/turn-server

\section{Protokolle}
\subsection{RTP}

\subsection{RTCP}
\subsection{RTSP}
\subsection{SDP}
% https://datatracker.ietf.org/doc/html/rfc4566#section-3.1
\subsection{SID}
% https://datatracker.ietf.org/doc/html/rfc3261
\subsection{STUN}
\subsection{TURN}
\subsection{WebRTC}

\section{Implementierung eines Live-Streams}

In diesem Kapitel wird ein experimentelles Kamera-System entwickelt, das die
oben erläuterten Protokolle / Technologien verwendet.

\subsection{Ziel}
Ziel dieses Experiments ist es ein MVP zu entwickeln und mögliche Probleme,
benötigten Zeitaufwand usw.\ zu ermitteln. Desweiteren ist ein ``Performance''
Vergleich mit anderen Live-Stream systemen interessant. Es gilt also die frage
zu klären, wie viel arbeit benötigt ein grundsätzlich funktionierendes
Software-Produkt das auf Echtzeit-Übertragung beruht.

\subsection{Inhalt des MVP}

Das zu implementierende Kamera-System wird lediglich eine einzige Kernfunktion
aufweisen: Sobald die Kamera an ist, streamt sie via WebRTC, mit ausreichend
FPS (mindestens 15 im durchschnitt) in ausreichender Qualität (720 x\ 480),
ihre Aufnahmen an ein User Interface. Dieses wird im browser laufen, muss aber
ausreichend Alternativen für andere Plattformen aufweisen (Nativ, Smartphone
usw.). Das User Interface und die Kamera starten die Aushandlung des
WebRTC-Streams über den Signaling Server. D.h.\ sie versenden SDP (Offer /
Answer) und tauschen ihre ICE-Candidates aus.

\subsection{Architektur}

Die Architektur ist sehr simpel. Sie besteht lediglich aus 3 Kernelementen:

\begin{enumerate}
	\item Embedded-Gerät mit einer Kamera, zur Erfassung der Daten und zum
		Streaming
	\item Signaling-Server, zur Aushandlung
	\item User Interface, zum Empfangen des Streams
\end{enumerate}

Die Hardware wird ein simpler Raspberry PI V4 mit 8GB RAM sein. Dieser kann
durch diverse Drittanbieter mit einem kostengünstigen Kamera-Modul erweitert
werden.

Auf der Hardware wird eine Raspberry PI OS Installation laufen auf der ein
Programm läuft das sich um den Stream kümmert.

Der Signaling-Server wird defacto ein Secure-WebSocket-Server sein, der zwei
WebSocket-Verbindungen miteinander verknüpft. So können sich zwei Clients durch
ein Shared-Secret (die Room-Id welche eine 256bit entropie ist) über diesen in
kontakt treten.

Das Interface wird lediglich dank der fixen 

\subsection{Signaling Server}



\section{Benchmarks}

\section{Auswertung}

\section{Nächste Schritte}

\large{IPV6 only => NAT holepunching entfällt}

\section{Abbildungsverzeichnis}
abc
def

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,references}

\end{document}
