\documentclass[journal]{IEEEtran}

\usepackage[a4paper, left=2cm, right=2cm, top=2cm, bottom=3cm]{geometry}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{lipsum}
\usepackage{xcolor}

\hypersetup{colorlinks=true, allcolors=black}

\title{Implementierung eines Atuhentifizierungs-Servers mit FIDO2 Support}
\author{
	\IEEEauthorblockN{Mara Schulke \textit{(Matrikel-Nr. 20215853)}}\\
	\IEEEauthorblockA{
		Technische Hochschule Brandenburg \\
		B.Sc. IT Sicherheit \\
		Hardware Sicherheit
	}
}

\begin{document}

\markboth{Hausarbeit Hardware Sicherheit – Mara Schulke}{}
\IEEEspecialpapernotice{
	betreut durch Prof.\ Dr.\ Oliver Stecklina\\
	Sommersemester 2022\\
	Abgabetermin \today
}

\maketitle

\begin{abstract}
\end{abstract}

\section{Einleitung}
\IEEEPARstart{A}{\MakeLowercase{uthentifizierung}} ist eines der größten
Probleme die durch verteilte Systeme entstehen. Es gibt zahlreiche
Möglichkeiten die Identität einer Gegenseite sicherzustellen allerdings weisen
viele von ihnen Schwachstellen hinsichtlich Man-In-The-Middle-Attacken und
basieren auf der Annahme, dass das System des Nutzers nicht kompromitiert
wurde. \textcolor{red}{tbd}

\section{Der FIDO2 Standard}

FIDO2 steht für \textit{F}ast \textit{ID}entity \textit{O}nline 2 und ist ein von
der FIDO Alliance entwickleter, offener und lizenzfreier Standard für
Hardware-Token gestützte Authentifizierung. (\textcolor{red}{quote})

Ein Hardware-Token (kann auch in Form eines Trusted-Plattform-Moduls oder als
Teil des Betriebssystems implementiert sein) ist ein physischer Speicher für
die FIDO Schlüsselpaare eines Nutzers. Kernmerkmale die FIDO2 von
herkömmlicher asymmetrischer Kryptografie unterscheiden sind beispielsweise die
Isolation der privaten Schlüssel auf dem Hardware-Token, die Notwendigkeit
einer Nutzerinteraktion zum Verwenden eines privaten Schlüssels und die
Generierung von einem Schlüsselpaar pro Online-Dienst.

Durch all diese Eigenschaften werden Schlsselverluste unwahrscheinlicher und
weniger Sicherheitskritisch, da selbst bei einem hypothetischen
Schlüsselverlustes der Schaden immer auf einen Online-Dienst begrenzt ist.
Die größte Schwachstelle ist allerdings der physische Diebstahl des
Hardware-Tokens, da dessen Besitz ausreicht für Impersonation-Attacken. Eine
Absicherung dagegen kann eine biometrische Authentifizierung erfolgen bevor ein
privater Schlüssel verwendet werden kann - wie beispielsweise bei FaceID.
\textcolor{red}{tbd}

\subsection{Welche Probleme löst FIDO2?}

Die Notwendigkeit für einen solchen Standard hat sich in den letzten Jahren
immer stärker gezeigt, da die klassische Knowledge-Based-Authentication
(\textcolor{red}{KBA})
durch zunehmende Rechenleistung und effizientere Angriffe immer unsicherer und
unhandlicher für Nutzer wird. Die minimale Passwortlängen steigen
dementsprechend an und führen zur Wiederverwendung von gleichen Login-Daten für
mehrere Online-Dienste. Bekannte Lösungen sind die Verwendung von sog.
Passwort-Managern um lange und zufällige Passwörter für verschiedenste
Online-Dienste zu verwenden ohne, dass sich Nutzer diese merken müssen. Solche
Passwort-Manager sind zwar eine Lösung für die sichere Aufbewahrung von langen
Passwörtern, können aber nicht die durch \textcolor{red}{KBA} eröffneten
Angriffsvektoren wie z.B. Man-In-The-Middle-Attacken. So bald ein Angreifer
in den Besitz des geheimen Wissens (in diesem Fall das Passwort) gelangt kann
dieser uneingeschränkt und unbegegrenzt oft auf das Zielsystem zugreifen, bis
der Nutzer seine Daten ändert (vorausgesetzt, der Angreifer hat dies noch nicht
getan).

Durch den Wechsel von \textcolor{red}{KBA} auf Zero-Knowledge-Proof basierte
Authentifizierungsmethoden lassen sich ganze Angriffsvektoren ausschließen, da
ein kompromitierter Server oder eine kompromitierte Verbindung niemals das
geheime Wissen des Nutzers einem Angreifer zugänglich machen. Das heißt, dass
sich ein Angreifer im Falle einer kompromitierten Verbindung maximal in die
Sitzung des Nutzers einschleichen könnte, allerdings bei der nächsten
Authentifizierung nicht erneut die Identität des Nutzers beweisen könnte und
somit den Zugriff verlieren würde.

Im Falle von FIDO2 kennt nichtmal der Nutzer selber seine Schlüssel da diese
auf einem Trusted-Plattform-Modul \textcolor{red}{TPM} oder einem externen
Hardware-Token gespeichert wird und der Beweis der Identität durch die Signatur
einer vom Authentifizierungs-Server ausgestellten Challange erfolgt die das
\textcolor{red}{TPM} oder der Hardware-Token intern durchführen und dem Nutzer
nur die Signatur zurückgeben. So stellt selbst ein kompromitiertes Nutzersystem
nur eine temporäre Schwachstelle dar.


\section{Relevante Protokolle: CTAP \& WebAuthn}

Der FIDO2 Standard umfasst hauptsächlich die beiden Protokolle \textit{CTAP}
und \textit{WebAuthn}. Diese unterteilen den gesammten
Authentifizierungsvorgang in
zwei Bereiche:

\textit{Client zu Authenticator} also die Kommunikation zwischen dem
Nutzersystem und dem Hardware-Token oder TPM und \textit{Client zu Server}, die
Kommunikation zwischen dem Nutzersystem und dem Online-Dienst bei dem sich der
Nutzer authentifizieren möchte.

\textcolor{red}{grafik}

\subsection{Gemeinsame Begriffsdefinitionen}

\subsubsection{Relying Party}

Ein Online-Dienst der den FIDO2 Standard zur Nutzerauthentifizierung verwendet.

\subsubsection{Authenticator}

Ein externer Hardware-Token oder ein Teil des Betriebssystems (z.B. über ein
TPM implementiert) der FIDO2 Schlüsselpaare verwaltet.

\subsubsection{Credential}

Ein FIDO2 Schlüssel

\subsubsection{CBOR}

Concise Binary Object Representation, ein Binär-Format zur Darstellung von JSON Objekten.

\subsection{CTAP}

Das Client-To-Authenticator-Protocol kurz \textcolor{red}{CTAP} ist Teil
des FIDO2 Standards und beschreibt den Ablauf der Kommunikation zwischen einem
Nutzersystem und dem Hardware-Token beziehungsweise dem Authenticator.

Neben einer Spezifikation für den Transportlayer / die Nachrichtenstruktur
besteht das Protokoll primär aus der sogenannten ``Authenticator API'' - diese
beschreibt Operationen die ein Nutzersystem auf einem Authenticator ausführen kann.

Spezifiziert sind die folgenden 6 Operationen:

\begin{enumerate}
	\item \textit{authenticatorMakeCredential} - Schlüsselpaar für eine
		``Relying Party'' erstellen
	\item \textit{authenticatorGetAssertion} - Signatur einer Challange
	\item \textit{authenticatorGetNextAssertion} - Nächste Signatur der
		Challange erhalten bei mehreren Schlüsselpaaren
	\item \textit{authenticatorGetInfo} - Informationen über die Fähigkeiten
		des Authenticators
	\item \textit{authenticatorClientPIN} - Setzt den Authenticator-PIN
	\item \textit{authenticatorReset} - Zurücksetzen auf Werkseinstellungen
\end{enumerate}

Die im Standard beschriebenen Transportlayer umfassen USB, NFC oder Bluetooth
Low Energy. Für jeden dieser Transportlayer gibt es eigene Mechanismen zum
sicheren Verbindungsaufbau und zur Nachrichtenstruktur.

\subsection{WebAuthn}


\section{Implementierung des Authetifizierungs-Servers}

\section{Technische Dokumentation}

Der Server öffnet den TCP Port 8080 und erwartet eine externe TLS
Terminierung. Tokens können dem Server über den \texttt{Authorization} Header
mitgegeben werden und der \texttt{Content-Type} aller Anfragen und Antworten
ist ausschließlich \texttt{application/json}.

\subsection{/auth/signup - Nutzer erstellen}

\begin{itemize}
	\setlength{\leftskip}{1.5cm}
	\setlength{\itemsep}{0pt}
	\item[Methode:] POST
	\item[Token:] -
	\item[Eingabe:] Credentials \{ email, password \}
	\item[Ausgabe:] UserDetails \{ token, verified, keys \}
	\item[Beschreibung:] Erstellt einen unverifizierten Nutzer ohne FIDO2 Keys.
		Gibt einen Verifizierungscode in den Server-Logs aus (könnte in einem
		echten Szenario per E-Mail verschickt werden).
\end{itemize}

\subsection{/auth/verify - Nutzer verifizieren}

\begin{itemize}
	\setlength{\leftskip}{1.5cm}
	\setlength{\itemsep}{0pt}
	\item[Methode:] POST
	\item[Token:] Notwendig
	\item[Eingabe:] Verification \{ code \}
	\item[Ausgabe:] -
	\item[Beschreibung:] Verifiziert einen Nutzer falls der Code mit dem bei
		der Registrierung generierten Code übereinstimmt.
\end{itemize}


\subsection{/auth/login - Nutzer anmelden}

\begin{itemize}
	\setlength{\leftskip}{1.5cm}
	\setlength{\itemsep}{0pt}
	\item[Methode:] POST
	\item[Token:] -
	\item[Eingabe:] Credentials \{ email, password \}
	\item[Ausgabe:] UserDetails \{ token, verified, keys \} | \textcolor{red}{webauthn challange}
	\item[Beschreibung:] Gibt dem Nutzer entweder seine UserDetails zurück oder
		stellt eine WebAuthn Authetifizierungs-Challange die der Nutzer
		signiert bei dem Endpunkt \textit{/auth/fido2/login} enreichen muss
		falls ein FIDO2 Schlüssel hinterlegt wurde.
\end{itemize}

\subsection{/auth/fido2/login - Nutzer mit WebAuthn anmelden}

\begin{itemize}
	\setlength{\leftskip}{1.5cm}
	\setlength{\itemsep}{0pt}
	\item[Methode:] POST
	\item[Token:] -
	\item[Eingabe:] \textcolor{red}{challange}
	\item[Ausgabe:] UserDetails \{ token, verified, keys \}
	\item[Beschreibung:] Validiert die WebAuthn Challange des Nutzers mit den
		hinterlegten FIDO2 Schlüsseln und gibt bei erfolgreicher Validierung
		dem Nutzer seine UserDetails zurück.
\end{itemize}

\subsection{/auth/fido2/challenges - WebAuthn Registrierungs Challange}

\begin{itemize}
	\setlength{\leftskip}{1.5cm}
	\setlength{\itemsep}{0pt}
	\item[Methode:] POST
	\item[Token:] Notwendig
	\item[Eingabe:] -
	\item[Ausgabe:] \textcolor{red}{ccr}
	\item[Beschreibung:] Startet einen Registrierungsprozess für einen FIDO2
		Schlüssel. Setzt Serverseitig den ``Key-Registration-State'' eines
		Nutzers und gibt eine Registrierungs-Challange zurück.
\end{itemize}

\subsection{/auth/fido2/keys - WebAuthn Registrierung abschließen}

\begin{itemize}
	\setlength{\leftskip}{1.5cm}
	\setlength{\itemsep}{0pt}
	\item[Methode:] POST
	\item[Token:] Notwendig
	\item[Eingabe:] \textcolor{red}{PublicKeyCredential}
	\item[Ausgabe:] Key \{ id \}
	\item[Beschreibung:] Nimmt die CTAP Ausgabe der
		``authenticatorMakeCredential'' Operation an und ordnet diesen
		Schlüssel dem Nutzer zu.
\end{itemize}

\subsection{/auth/fido2/keys/:id - WebAuthn Schlüssel entfernen}

\begin{itemize}
	\setlength{\leftskip}{1.5cm}
	\setlength{\itemsep}{0pt}
	\item[Methode:] DELETE
	\item[Token:] Notwendig
	\item[Eingabe:] \textit{/:id}
	\item[Ausgabe:] -
	\item[Beschreibung:] Entfernt einen FIDO2 Schlüssel anhand seiner ID.\@
\end{itemize}


    %app.at("/auth/login").post(auth::login);
    %app.at("/auth/signup").post(auth::signup);
    %app.at("/auth/verify")
        %.with(middleware::authenticated)
        %.post(auth::verify);

    %app.at("/auth/fido2/login").post(auth::fido2::login);
    %app.at("/auth/fido2/challenges")
        %.with(middleware::authenticated)
        %.post(auth::fido2::create_challenge);
    %app.at("/auth/fido2/keys")
        %.with(middleware::authenticated)
        %.post(auth::fido2::store_key);
    %app.at("/auth/fido2/keys/:id")
        %.with(middleware::authenticated)
        %.delete(auth::fido2::remove_key);

\section{Auswertung}

\section{Abbildungsverzeichnis}

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,references}

\end{document}
