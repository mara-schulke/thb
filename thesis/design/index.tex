\section{System Design}

This chapter describes the design of \textsc{Natural}, the proposed NL2SQL system, 
addressing limitations and research gaps identified in the literature review.
The design follows a modular architecture that leverages both traditional computer
science algorithms and machine learning models to achieve robust, portable and
extensible natural language to SQL translation capabilities.

\subsection{Overview}

The core of the proposed design is the query function $nq$ which utilizes
example selection ($\sigma$), query preprocessing, schema subsetting ($\phi$),
model inference ($\pi$), self-correction ($\rho$) and majority voting ($\nu$)
in order to convert a natural language query $q$ into a corresponding SQL query $\omega$.

% TODO: Revisit
% TODO: Draw diagram of nq, this is an itermediate placeholder
\begin{verbatim}
Query -> Zero-Shot -> Selection -> Generation [ Subsetting -> Few-Shot -> Refinement ] -> Voting
\end{verbatim}
% TODO: Reference figure correctly

\begin{algorithm}

\caption{The $nq$ function}\label{algorithms:nq}

\begin{algorithmic}[1]
\Require $q \in \mathcal{Q}$, $s \in \mathcal{S}$, $e \in \mathcal{E}$, $v \in \mathcal{V}$, $d \in \mathcal{D}$
\Require $k \in \{ n \in N\ |\ 2n + 1 \}, k \geq 1$
\State $z \gets \pi(\emptyset,q, s)$       \Comment{Zero shot inference}
\State $S \gets \sigma(q,z,s,v,d)$         \Comment{Example selection is performed}
\State $C \gets \emptyset$                 \Comment{The set of query candidates}
\While{$|C| < k$}                          \Comment{While not enough candidates exist}
    \State $s' \gets \phi(C, s)$           \Comment{Identify relevant schema subset}
    \State $c \gets \pi(S, q, s')$         \Comment{Prompt model for next candidate}

    \If{$e(nc)$}                           \Comment{Evaluate the next candidate}
        \State $C \gets \{c\} \cup C$      \Comment{Extend the candidates}
    \EndIf

    \State $c' \gets \rho(q, s', e, v)$  \Comment{Refine via self correction}

    \If{$e(c')$}                          \Comment{Evaluate the refined candidate}
        \State $C \gets \{c'\} \cup C$    \Comment{Extend the candidates}
    \EndIf
\EndWhile
\State \Return $\nu(C, e)$               \Comment{Return most prevalent result}
\end{algorithmic}

\end{algorithm}

This design expands on concepts from DAIL-SQL \citep{DAIL}, X, Y and Z \textcolor{red}{look up}.
The most notable characteristics of \textsc{Natural} lie in it's capabilities for continuous
learning, example selection and portability which allow the system to iteratively
adapt to unseen database schemas.

Prior to using $nq$ to answer natural language questions, historical datasets must be sampled
such that an embedding space $\mathcal{V}$ and distance index $\mathcal{D}$ can be supplied
to $nq$.

\subimport{}{sampling}

\subimport{}{definitions}

