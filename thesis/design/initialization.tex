\subsection{Initialization}

Before processing queries, \textsc{Natural} requires initialization
with historical data to construct an embedding space $v \in \mathcal{V}$ and
schema distance index $d \in \mathcal{D}$. This preprocessing phase analyzes
datasets and previous user interactions to enable semantically-aware example selection.

The initialization process consists of two components: (1) embedding generation
for semantic similarity computation, and (2) schema indexing for structural similarity
measurement. These components support the example selection function $\sigma$.

\subsubsection{Embedding}\label{design:embedding}

\textsc{Natural} constructs an embedding space $v$ to enable semantic similarity search
\citep{DAIL-SQL}. It uses cosine similarity to identify relevant examples based
on natural language queries and SQL statements, allowing efficient retrieval from
large collections of question-answer pairs.

We therefore embed a set of training samples $\mathcal{T} = \{(q_1, \omega_1), ..., (q_n, \omega_n)\}$
into an embedding space $v$, where each $q_i$ is a natural language question and $\omega_i$
is the corresponding SQL query.

The embedding space $v$ can be formally defined as:

$$v = \{~(q, \iota(q), \omega, \iota(\omega))~|~(q, \omega) \in \mathcal{T}~\}$$

where $\iota$ is the embedding function that maps text to vector representations.

\subsubsection{Schema Indexing}

To choose relevant samples for few-shot learning,
the SQL queries chosen as examples should use
structurally similar database schemas to minimize the structural
difference between the selected samples and the ground truth query for a
natural language question.

For example $\omega_{ground}$ the question ``Give me all contacts for the user with the id 10''
might look different depending on the database schema, thus selecting
samples based only on the similarity of the natural language question will yield inferior
sample quality.

\begin{figure}[ht]
  \vspace{1em}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \begin{verbatim}
CREATE TABLE users (
  id TEXT PRIMARY KEY
);

CREATE TABLE contacts (
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  FOREIGN KEY (user_id) 
   REFERENCES users(id),
  PRIMARY KEY (user_id, name)
);
    \end{verbatim}
    \caption{Normalized schema}
    \label{figure:schema-normalized}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.35\linewidth}
    \begin{verbatim}
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  contacts TEXT[] NOT NULL
);
    \end{verbatim}
    \vspace{3.75em}
    \caption{Denormalized schema}
    \label{figure:schema-denormalized}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{figure}

Given the database schemas in figures~\ref{figure:schema-normalized} and~\ref{figure:schema-denormalized}
respective definitions of $\omega_{ground}$ would be~\ref{figure:sql-join-example}
and~\ref{figure:sql-array-example}.

\begin{figure}[ht]
  \vspace{1em}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \begin{verbatim}
SELECT contacts.name
FROM users
JOIN contacts
  ON contacts.user_id = users.id
WHERE users.id = 10;
    \end{verbatim}
    \caption{SQL JOIN selection}
    \label{figure:sql-join-example}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.35\linewidth}
    \centering
    \begin{verbatim}
SELECT contacts
FROM users
WHERE id = 10;
    \end{verbatim}
    \vspace{1.3em}
    \caption{SQL Array selection}
    \label{figure:sql-array-example}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{figure}


Figures~\ref{figure:sql-join-example} and~\ref{figure:sql-array-example} show
the structural similarity of the database schema is crucial to
the relevance of an example.

\paragraph{Graph Representation}\label{design:graph-repr}

To determine structural similarity of database schemas, we propose
using graph representation as a data definition language (DDL)
independent representation of the database structure. A graph
representation allows leveraging established methods for measuring graph similarity
such as Wasserstein-Weisfeiler-Lehman graph kernels \citep{WWL}. 
Given a database schema $s$ we define the corresponding graph $G_s = (V, E, \ell, w)$ as:

\begin{enumerate}
    \item $V = V_t \cup V_c$ where $V_t$ represents table nodes and $V_c$ represents column nodes
    \item $E = E_{tc} \cup E_{fk} \cup E_{ref}$ where:
        \begin{itemize}
            \item $E_{tc}$ are table-column edges
            \item $E_{fk}$ are foreign key relationship edges between tables
            \item $E_{ref}$ are reference edges between foreign key columns
        \end{itemize}
    \item Each node $v \in V$ has a semantic label $\ell(v) \in \{1, 2, \ldots, 9\}$ where:
        \begin{itemize}
            \item $\ell(v) = 1$ for table nodes
            \item $\ell(v) = 2$ for generic column nodes
            \item $\ell(v) = 3$ for primary key columns
            \item $\ell(v) = 4$ for foreign key columns
            \item $\ell(v) = 5$ for text columns
            \item $\ell(v) = 6$ for numeric columns
            \item $\ell(v) = 7$ for datetime columns
            \item $\ell(v) = 8$ for boolean columns
            \item $\ell(v) = 9$ for other/unknown data types
        \end{itemize}
    \item Each edge $e \in E$ has a weight $w(e) \in \{0.5, 0.9, 1.0\}$ reflecting its structural importance:
        \begin{itemize}
            \item $w(e) = 1.0$ for foreign key relationships (highest importance)
            \item $w(e) = 0.9$ for column foreign key reference edges
            \item $w(e) = 0.5$ for table-column edges
        \end{itemize}
\end{enumerate}

We define the structural similarity of two databases as the topological distance
of their graphs. The graph representation captures essential
structure through semantic node labeling that prioritizes constraints over data
types: primary key columns receive label 3 regardless of data
type, foreign key columns receive label 4, and only then are remaining columns
categorized by data type (text=5, numeric=6, datetime=7, boolean=8, other=9).
This hierarchical labeling ensures that structural relationships take
precedence over exact content, while omitting table names, column names and
domain terminology for schema-agnostic comparison.

The graph representation of the database schemas introduced in~\ref{figure:schema-normalized}
and~\ref{figure:schema-denormalized} are therefore:

\begin{figure}[ht]
  \vspace{1em}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \centering
    \begin{tikzpicture}[node distance={15mm}, table/.style = {draw,circle}, column/.style = {draw,dashed,circle}]

      \node[table] (users) at (0,0) {1}; 
      \node[table] (contacts) at (2,0) {1}; 
      
      \node[column] (users_id) [below left of=users] {3}; 
      
      \node[column] (contacts_user_id) [below left of=contacts] {4};
      \node[column] (contacts_name) [below right of=contacts] {5};
      
      \draw[dashed] (users) -- (users_id); 
      \draw[dashed] (contacts) -- (contacts_user_id); 
      \draw[dashed] (contacts) -- (contacts_name); 
      
      \draw[thick] (users) to [out=10, in=170] (contacts);
      
      \draw (users_id) to [out=10, in=170] (contacts_user_id); 
    \end{tikzpicture} 
    \caption{Normalized graph repr.}
    \label{figure:normalized-graph-representation}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \centering
    \begin{tikzpicture}[node distance={15mm}, table/.style = {draw,circle}, column/.style = {draw,dashed,circle}]
      \node[table] (users) at (0,0) {1}; 
      
      \node[column] (users_id) [below left of=users] {3}; 
      \node[column] (users_contacts) [below right of=users] {9};
      
      \draw[dashed] (users) -- (users_id); 
      \draw[dashed] (users) -- (users_contacts); 
    \end{tikzpicture} 
    \caption{Denormalized graph repr.}
    \label{figure:denormalized-graph-representation}
  \end{minipage}
  \hfill
  \vspace{1em}
  
  \begin{minipage}{\linewidth}
    \centering
    \vspace{0.5em}
    \small
    \textbf{Legend:} \cir{}~table~~\cir{dashed}~column~~\textbf{-}~foreign key~~--~reference~~- -~table-column
  \end{minipage}
\end{figure}

The $\Delta$ of the order of the graphs~\ref{figure:normalized-graph-representation}
and~\ref{figure:denormalized-graph-representation}
further highlight the structural difference between the two schemas.

\paragraph{Distance Measurement}

To measure the distance between the graphs displayed in~\ref{figure:normalized-graph-representation}
and~\ref{figure:denormalized-graph-representation}, we employ the
Wasserstein Weisfeiler-Lehman (WWL) graph kernel method \citep{WWL}.

WWL kernels compute structural similarity by combining discrete Weisfeiler-Lehman
graph features with continuous optimal transport theory. The method first extracts
WL features from the labeled graph structure, then computes the Wasserstein distance
between the resulting feature distributions. For two graphs $G$ and
$G'$ with semantic node labels, the distance is computed as:

\begin{equation}
D^{f}_{W}(G, G') = W_1(f(G), f(G'))
\end{equation}

as introduced by \citeauthor{WWL} in \citeyear{WWL}.

For the database schemas, the normalized
schema $G_{norm}$ (see figure~\ref{figure:normalized-graph-representation})
with 5 nodes and 5 edges and denormalized schema $G_{denorm}$ (see figure~\ref{figure:denormalized-graph-representation})
with 3 nodes and 2 edges show significant topological differences.
The WWL distance captures the reduction in graph complexity (fewer nodes and edges)
and the loss of relational structure (elimination of foreign key relationships),
resulting in a substantial distance reflecting their structural dissimilarity
despite equivalent logical data: $D^{f}_{W}(G_{norm}, G_{denorm}) \approx 0.78$.


\paragraph{Distance Index}

The distance index $d$ maintains precomputed distances between
observed database schemas, enabling efficient retrieval of structurally similar
databases during sample selection. This index is constructed as a set of
schema-distance tuples $\{(sm_1, di_1), \ldots, (sm_i, di_i)\}$ where $sm_i$ is
a database schema name and $di_i$ denotes its WWL distance to the current schema.

