\subsection{Initialization}

Before the \textsc{Natural} system can process queries, it requires initialization
with historical data to construct a specific embedding space $v \in \mathcal{V}$ and
schema distance index $d \in \mathcal{D}$. This preprocessing phase analyzes existing
datasets and previous user interactions to enable semantically-aware example selection.

The initialization process consists of two main components: (1) embedding generation
for semantic similarity computation, and (2) schema indexing for structural similarity
measurement. These components work together to support the example selection function $\sigma$.

\subsubsection{Embedding}\label{design:embedding}

Building upon DAIL-SQL's masked example selection approach, \textsc{Natural} constructs
an embedding space $v$ to enable semantic similarity search. The system uses cosine
similarity to identify relevant examples based on masked representations of both
natural language queries and SQL statements, allowing efficient retrieval from
large collections of question-answer pairs.

We therefore embed a set of training samples $\mathcal{T} = \{(q_1, \omega_1), ..., (q_n, \omega_n)\}$
into an embedding space $v$, where each $q_i$ is a natural language question and $\omega_i$
is the corresponding SQL query.

The embedding space $v$ can be formally defined as:

$$v = \{~(q, \iota(mask(q)), \omega, \iota(mask(\omega)))~|~(q, \omega) \in \mathcal{T}~\}$$

where $mask$ represents the masking function described in sections~\ref{design:nl-masking}
and~\ref{design:sql-masking}, and $\iota$ is the embedding function that maps text to vector representations.

\paragraph{Natural Language Masking}\label{design:nl-masking}

Masking of natural language is the process of replacing all words which are not
deemed \textit{structurally relevant} with the \texttt{<mask>} token. All words
$w$ in a constant whitelist $\mathcal{W}$ are determined structurally relevant.
The constant $\mathcal{W}$ contains common structural SQL keywords and is determined empirically.

Working with masked language enables the system to capture semantic patterns
independently of domain terminology, improving the generalizability across
domains.

Given $\mathcal{W} = \{\text{list}, \text{show}, \text{all}, \text{the},
\text{with}\}$ the natural language
questions:

\begin{verbatim}
Show all customers with the firstname John
List all products with the name iPhone
\end{verbatim}

Will get masked into the same sentence, such that the semantic words are
maintained, but domain specific terminology is discarded:

\begin{verbatim}
Show all <mask> with the <mask> <mask>
\end{verbatim}

\paragraph{SQL Masking}\label{design:sql-masking}

Masking SQL queries refers to transforming all identifiers contained in 
a SQL query to \texttt{<mask>} and all value literals to \texttt{<value>}.

Thus, the queries:

\begin{verbatim}
SELECT * FROM customers WHERE firstname = 'John'
SELECT * FROM products WHERE name = 'iPhone'
\end{verbatim}

get masked to:

\begin{verbatim}
SELECT * FROM <mask> WHERE <mask> = <value>
\end{verbatim}



\subsubsection{Schema Indexing}

To choose the most relevant subset of samples for few-shot learning,
it is important that the SQL queries we choose as examples are written for
structurally similar database schemas in order to minimize the structural
difference between the selected samples and the ground truth query for a given
natural language question.

For example $\omega_{ground}$ the question ``Give me all contacts for the user with the id 10''
might look different depending on the database schema at hand, thus only selecting
samples based on the similarity of the natural language question will yield inferior
sample quality.

\begin{figure}[ht]
  \vspace{1em}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \begin{verbatim}
CREATE TABLE users (
  id TEXT PRIMARY KEY
);

CREATE TABLE contacts (
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  FOREIGN KEY (user_id) 
   REFERENCES users(id),
  PRIMARY KEY (user_id, name)
);
    \end{verbatim}
    \caption{Normalized schema}
    \label{figure:schema-normalized}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.35\linewidth}
    \begin{verbatim}
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  contacts TEXT[] NOT NULL
);
    \end{verbatim}
    \vspace{3.75em}
    \caption{Denormalized schema}
    \label{figure:schema-denormalized}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{figure}

Given the database schemas in figures~\ref{figure:schema-normalized} and~\ref{figure:schema-denormalized}
respective definitions of $\omega_{ground}$ would be~\ref{figure:sql-join-example}
and~\ref{figure:sql-array-example}.

\begin{figure}[ht]
  \vspace{1em}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \begin{verbatim}
SELECT contacts.name
FROM users
JOIN contacts
  ON contacts.user_id = users.id
WHERE users.id = 10;
    \end{verbatim}
    \caption{SQL JOIN selection}
    \label{figure:sql-join-example}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.35\linewidth}
    \centering
    \begin{verbatim}
SELECT contacts
FROM users
WHERE id = 10;
    \end{verbatim}
    \vspace{1.3em}
    \caption{SQL Array selection}
    \label{figure:sql-array-example}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{figure}


As shown in the figures~\ref{figure:sql-join-example} and~\ref{figure:sql-array-example}
the structural similarity of the underlying database schema is a crucial component
of the relevance of an example.

\paragraph{Graph Representation}

To determine structural similarity of database schemas systematically, we propose
using graph representation of database schemas as a data definition language (DDL)
independent representation of the database structure. Choosing a graph
representation allows us to leverage established methods for measuring graph similarity
such as Wasserstein-Weisfeiler-Lehman graph kernels \citep{WWL}. 
Given a database schema $s$ we define the corresponding graph $G_s = (V, E, \ell, w)$ as:

\begin{enumerate}
    \item $V = V_t \cup V_c$ where $V_t$ represents table nodes and $V_c$ represents column nodes
    \item $E = E_{tc} \cup E_{fk} \cup E_{ref}$ where:
        \begin{itemize}
            \item $E_{tc}$ are table-column edges
            \item $E_{fk}$ are foreign key relationship edges between tables
            \item $E_{ref}$ are reference edges between foreign key columns
        \end{itemize}
    \item Each node $v \in V$ has a semantic label $\ell(v) \in \{1, 2, \ldots, 9\}$ where:
        \begin{itemize}
            \item $\ell(v) = 1$ for table nodes
            \item $\ell(v) = 2$ for generic column nodes
            \item $\ell(v) = 3$ for primary key columns
            \item $\ell(v) = 4$ for foreign key columns
            \item $\ell(v) = 5$ for text columns
            \item $\ell(v) = 6$ for numeric columns
            \item $\ell(v) = 7$ for datetime columns
            \item $\ell(v) = 8$ for boolean columns
            \item $\ell(v) = 9$ for other/unknown data types
        \end{itemize}
    \item Each edge $e \in E$ has a weight $w(e) \in \{0.5, 0.9, 1.0\}$ reflecting its structural importance:
        \begin{itemize}
            \item $w(e) = 1.0$ for foreign key relationships (highest importance)
            \item $w(e) = 0.9$ for column foreign key reference edges
            \item $w(e) = 0.5$ for table-column edges
        \end{itemize}
\end{enumerate}

We define the structural similarity of two databases as the topological distance
of the respective graphs. The graph representation captures essential schema
structure through semantic node labeling that prioritizes constraints over data
types: primary key columns receive label 3 regardless of their underlying data
type, foreign key columns receive label 4, and only then are remaining columns
categorized by data type (text=5, numeric=6, datetime=7, boolean=8, other=9).
This hierarchical labeling ensures that structural relationships take
precedence over exact content, while omitting table names, column names and
domain terminology to achieve schema-agnostic comparison.

The graph representation of the database schemas introduced in~\ref{figure:schema-normalized}
and~\ref{figure:schema-denormalized} are therefore:

\begin{figure}[ht]
  \vspace{1em}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \centering
    \begin{tikzpicture}[node distance={15mm}, table/.style = {draw,circle}, column/.style = {draw,dashed,circle}]

      \node[table] (users) at (0,0) {1}; 
      \node[table] (contacts) at (2,0) {1}; 
      
      \node[column] (users_id) [below left of=users] {3}; 
      
      \node[column] (contacts_user_id) [below left of=contacts] {4};
      \node[column] (contacts_name) [below right of=contacts] {5};
      
      \draw[dashed] (users) -- (users_id); 
      \draw[dashed] (contacts) -- (contacts_user_id); 
      \draw[dashed] (contacts) -- (contacts_name); 
      
      \draw[thick] (users) to [out=10, in=170] (contacts);
      
      \draw (users_id) to [out=10, in=170] (contacts_user_id); 
    \end{tikzpicture} 
    \caption{Normalized graph repr.}
    \label{figure:normalized-graph-representation}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \centering
    \begin{tikzpicture}[node distance={15mm}, table/.style = {draw,circle}, column/.style = {draw,dashed,circle}]
      \node[table] (users) at (0,0) {1}; 
      
      \node[column] (users_id) [below left of=users] {3}; 
      \node[column] (users_contacts) [below right of=users] {9};
      
      \draw[dashed] (users) -- (users_id); 
      \draw[dashed] (users) -- (users_contacts); 
    \end{tikzpicture} 
    \caption{Denormalized graph repr.}
    \label{figure:denormalized-graph-representation}
  \end{minipage}
  \hfill
  \vspace{1em}
  
  \begin{minipage}{\linewidth}
    \centering
    \vspace{0.5em}
    \small
    \textbf{Legend:} \cir{}~table~~\cir{dashed}~column~~\textbf{-}~foreign key~~--~reference~~- -~table-column
  \end{minipage}
\end{figure}

The $\delta$ of the order of the graphs~\ref{figure:normalized-graph-representation}
and~\ref{figure:denormalized-graph-representation}
further highlight the structural difference between the two schemas.

\paragraph{Distance Measurement}

To measure the distance between the graphs displayed in~\ref{figure:normalized-graph-representation}
and~\ref{figure:denormalized-graph-representation}, we employ the
Wasserstein Weisfeiler-Lehman (WWL) graph kernel method \citep{WWL}.

WWL kernels compute structural similarity by combining discrete Weisfeiler-Lehman
graph features with continuous optimal transport theory. The method first extracts
WL features from the labeled graph structure, then computes the Wasserstein distance
between the resulting feature distributions. For two graphs $G$ and
$G'$ with semantic node labels, the distance is computed as:

\begin{equation}
D^{f}_{W}(G, G') = W_1(f(G), f(G'))
\end{equation}

as introduced by \citeauthor{WWL} in \citeyear{WWL}.

For the database schemas above, the graph representation of the normalized
schema $G_{norm}$ (see figure~\ref{figure:normalized-graph-representation})
with 5 nodes and 5 edges and denormalized schema $G_{denorm}$ (see figure~\ref{figure:denormalized-graph-representation})
with 3 nodes and 2 edges show significant topological differences.
The WWL distance captures both the reduction in graph complexity (fewer nodes and edges)
and the loss of relational structure (elimination of foreign key relationships),
resulting in a substantial distance value reflecting their structural dissimilarity
despite representing equivalent logical data with $D^{f}_{W}(G_{norm}, G_{denorm}) \approx 0.78$.


\paragraph{Distance Index}

The distance index $d$ maintains precomputed distances between
all observed database schemas, enabling efficient retrieval of structurally similar
databases during sample selection. This index is constructed as a set of
schema-distance tuples $\{(sm_1, di_1), \ldots, (sm_i, di_i)\}$ where $sm_i$ is
a database schema name and $di_i$ denotes its WWL distance to the current schema.

