\documentclass{article}

\usepackage[a4paper]{geometry}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}

\lstset{
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\begin{document}

\begin{titlepage}
	\begin{flushleft}
		TH Brandenburg \\
		Online Studiengang Medieninformatik \\
		Fachbereich Informatik \\
		Algorithmen und Datenstrukturen
	\end{flushleft}

	\vfill

	\begin{center}
		\Large{Einsendeaufgabe 1}\\[0.5em]
		\large{Sommersemester 2021}\\[0.25em]
		\large{Abgabetermin 18.04.2021}
	\end{center}

	\vfill

	\begin{flushright}
		Maximilian Schulke \\
		Matrikel-Nr. 20215853
	\end{flushright}
\end{titlepage}

\newpage

\section{Zweitkleinstes Element einer Folge}

Das zweitkleinste Element einer Folge von n $\geq$ 2 Zahlen soll bestimmt werden.

\subsection{Algorithmus in Pseudocode}

\begin{lstlisting}
def second_minimum(list):
    second = list[0]
    minimum = list[0]

    for n in list[1:]:
        if n > minimum:
            second = n
            break

    for n in list[1:]:
        if n < minimum:
            second = minimum
            minimum = n

    return second
\end{lstlisting}

\subsection{Laufzeit-Analyse}

Der Algorithmus braucht im \textbf{Best-Case n} Vergleiche, liegt also dementsprechend in $\Omega(n)$. Der Best-Case tritt ein,
wenn direkt das zweite Element größer als das erste ist, da dann die erste Schleife nach dem ersten Schritt abgebrochen wird und
die 2. Schleife immer genau $n - 1$ vergleiche ausführt.

Er braucht im \textbf{Worst-Case 2(n - 1)} Vergleiche und liegt daher in $O(n)$. Der Worst-Case kommt zustande wenn wir z.B. eine List der
Länge n betrachten, die n mal das gleiche Element enthält. Dann benötigen wir beim der ersten und der zweiten Schleife $n - 1$ Vergleiche.

\section{Asymptotische Notation}

Gegeben sei die Funktion $f(n) = 2n^2 + 3n\log_2n - 72$

\subsection{Beweis von $f(n) \in O(n^2)$}

\begin{align*}
	f(n) & = 2n^2 + 3n\log_2n - 72 \\
	     & \leq 2n^2 + 3n\log_2n   \\
	     & \leq 2n^2 + 3n^2        \\
	     & = 5n^2
\end{align*}

Somit können wir sagen, dass mit $c \geq 5$ und $n_0 = 1$ die Behauptung $f(n) \in O(n^2)$ gilt

\subsection{Beweis von $f(n) \in \Omega(n^2)$}

\begin{align*}
	f(n) & = 2n^2 + 3n\log_2n - 72 \\
	     & \geq 2n^2 - 72          \\
	     & \geq n^2
\end{align*}

Nun können wir $n_0$ als Schnittpunkt der beiden Funktionen $2n^2 - 72$ und $n^2$ berechnen.

\begin{align*}
	2n^2 - 72 & = n^2 \mid - 2n^2 \\
	- 72      & = -n^2 \mid * -1  \\
	72        & = n^2             \\
	n         & = \sqrt{72}
\end{align*}

Also, mit $c = 1$ und $n_0 = \lceil\sqrt{72}\rceil = 9$ gilt $f(n) \in \Omega(n^2)$

\subsection{Gilt $f(n) \in \Theta(n^2)$ ?}

$\Theta(g)$ ist im Skript mit der \emph{Definition 2.5} als $\{ \, f \mid f \in O(g) \wedge f \in \Omega(g) \, \}$ definiert.\\[0.5em]
Somit wissen wir, dass $f(n) \in \Theta(n^2)$, da wir in 2.1 und 2.2 gezeigt haben, dass $f \in O(g)$ und $f \in \Omega(g)$ gelten.

\section{Average-Case-Aufwand der binären Suche}

\subsection{Durchschnittliche Anzahl der Vergleiche für einen Hit}

\vspace{1em}

\begin{center}
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		Element    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
		\hline
		Vergleiche & 3 & 2 & 3 & 4 & 1 & 3 & 4 & 2 & 3 & 4 \\
		\hline
	\end{tabular}
\end{center}

\vspace{1em}

Macht in Summe 29 Vergleiche und somit $\frac{29}{10} = 2.9$ Vergleiche im Durchschnitt.

\subsection{Summenformel für Vergleiche bei $2^k - 1$ Elementen}

\begin{center}
	\vspace{1em}

	Beispiel für $k = 3$

	\vspace{1em}

	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		&  &  & 3 & & & \\
		\hline
		 & 1 & &  & & 5 & \\
		\hline
		0 &  & 2 &  & 4 &  & 6 \\
		\hline
	\end{tabular}

	\vspace{2em}

	Beispiel für $k = 4$

	\vspace{1em}

	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		   &   &   &   &   &   &   & 7 &   &   &    &    &    &    &    \\
		\hline
		   &   &   & 3 &   &   &   &   &   &   &    & 11 &    &    &    \\
		\hline
		   & 1 &   &   &   & 5 &   &   &   & 9 &    &    &    & 13 &    \\
		\hline
		0  &   & 2 &   & 4 &   & 6 &   & 8 &   & 10 &    & 12 &    & 14 \\
		\hline
	\end{tabular}
\end{center}

\newpage

Es gibt bei $2^k - 1$ immer einen perfekten, gleichmäßigen Baum und immer genau $\log_2n$ bzw. $k$ Ebenen.
Auf (einer 0 indizierten) Ebene $i$ haben wir den Baum $i$ Mal geteilt und vergleichen $(i + 1) * 2^i$ Elemente.
Wenn wir nun alle Ebenen addieren möchten, um die gesamt Anzahl der verglichenen Elemente bekommen möchten,
müssen wir lediglich alle Ebenen addieren. Also bei $k = 4$ wären wir bei $1 * 2^0 + 2 * 2^1 + 3 * 2^2 + 4 * 2^3$ Vergleichen.
Dies lässt sich durch die gaußsche Summenformel eleganter (und allgemeingültiger) Zusammenfassen zu $\sum_{i=0}^{k - 1} (i + 1) * 2^i$.




\end{document}
